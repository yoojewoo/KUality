# KUality
[과제 #1] 피보나치 수열 구현

2020271312 유제우

1. 피보나치 수열 설명

  피보나치 수열은 1번째 항과 2번째 항을 더하면 3번째 항이 되고, 2번째 항과 3번째 항을 더하면 4번째 항이 되는 수열이다. 정리하자면 n-2번째 항과 n-1번째 항을 더하면 n번째 항이 된다는 것이다. 이때 1번째 항 0이면 2번째 항이 1이 되고, 0을 제외한다면 1번째 항이 1로 시작될 수 있다. 
0번째 항부터 시작하는 경우를 식으로 표현해본다면 

F_0=0 

F_1=1 

F_n=F_(n-1)+F_(n-2) 로 표현할 수 있다. 

10번째 항까지만 전개해보자면 

0일 때 0

1일 때 1 

2일 때 2 

3일 때 3 

5일 때 5 

6일 때 8 

7일 떄 13 

8일 때 21 

9일 때 34 

10일 때 55 와 같이 피보나치 수열의 값이 나온다는 것을 알 수 있다.


2. 재귀 함수 설명
- 종료 조건 (Base Case)의 필요성과 역할

  재귀 함수는 자기 자신을 계속 해서 호출하기 때문에 메모리 속에 스택 프레임이 계속 쌓이게 된다. 계속 쌓이는 이 현상이 반복된다면 스택 안에 메모리가 넘쳐버리기 때문에 Stack Overflow가 발생하게 된다. 이를 방지하기 위해서 종료 조건이 필요하게 되는데 base case는 재귀 함수의 파라미터가 설정해놓은 조건과 일정하게 되면 재귀가 끝나며 함수가 종료되게 하는 역할을 한다.

- 중복 계산 발생 원인 및 해결 방안

  재귀 함수는 재귀 호출이 필요할 때마다 해야 하고 그에 따라 한번 계산 했던 함수가 다시 계산이 되어 중복된 작업이 많이 발생하고 실제로 코드를 실행할 때에도 출력 값이 나오는 데까지 시간이 조금 걸린다는 것을 확인할 수 있다. 이는 성능 저하를 초래하게 되는데 이를 해결하기 위한 대표적인 방법으로 Memoization과 Tabulation이 있다.

  Memoization은 중복 계산을 피하기 위한 방법으로 피보나치를 계산해서 배열에 저장해놓고 필요할 때 사용하는 방식이다. 값이 배열에 저장되어 있기 때문에 연산을 줄일 수 있고 그 덕분에 런타임 시간이 줄어들게 된다. 하지만 배열에 저장을 하기 때문에 공간을 많이 사용하게 되어 메모리 사용은 증가한다. 재귀 함수를 사용할 때 구현하는 경우가 많다.

  Tabulation은 Memoization과 굉장히 비슷하지만 앞서서는 피보나치를 계산을 하고 나서 배열에 저장을 했다면 Tabulation은 미리 피보나치 값을 모두 배열에 저장을 하고 나서 계산을 하는 방법이다. 이 때문에 Memoization과 비교했을 때 메모리 사용량이 더 많을 수 있고 Tabulation은 주로 반복문을 사용하는 경우 구현합니다.
